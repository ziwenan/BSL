% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cell.R
\name{cell}
\alias{cell}
\alias{cell_sim}
\alias{cell_sum}
\alias{cell_prior}
\alias{cell_logPrior}
\title{Cell biology example}
\usage{
cell_sim(theta, Yinit, rows, cols, sim_iters, num_obs)

cell_sum(Y, Yinit)

cell_prior(theta)

cell_logPrior(theta)
}
\arguments{
\item{theta}{A vector of proposed model parameters, \eqn{Pm} and \eqn{Pp}.}

\item{Yinit}{The initial matrix of cell presences of size \code{rows} by \code{cols}.}

\item{rows}{The number of rows in the lattice (rows in the cell location matrix).}

\item{cols}{The number of columns in the lattice (columns in the cell location matrix).}

\item{sim_iters}{The number of discretisation steps to get to when an observation is
actually taken. For example, if observations are taken every 5 minutes but the discretisation level is 2.5 minutes,
then \code{sim_iters} would be 2. Larger values of \code{sim_iters} lead to more ``accurate'' simulations from the model, but they also increase the simulation time.}

\item{num_obs}{The total number of images taken after initialisation.}

\item{Y}{A \code{rows} by \code{cols} by \code{num_obs} array of the cell presences at times \code{1:num_obs} (not time 0).}
}
\description{
This example estimates the probabilities of cell motility and
cell proliferation for a discrete-time stochastic model of
cell spreading. We provide the data and tuning parameters required to
reproduce the results in An et al. (2019).
}
\details{
Cell motility (movement) and proliferation (reproduction) cause
tumors to spread and wounds to heal. If we can measure cell proliferation
and cell motility under different situations, then we may be able to use
this information to determine the efficacy of different medical treatments.

A common method for measuring in vitro cell movement and proliferation is
the scratch assay. Cells form a layer on an assay and, once
they are completely covering the assay, a scratch is
made to separate the cells. Images of the cells are taken until the
scratch has closed up and the cells are in contact again.
Each image can be converted to a binary matrix by forming a lattice
and recording the binary matrix (of size \code{rows} \eqn{x} \code{cols}) of cell presences.

The model that we consider is a random walk model with parameters for the probability
of cell movement (\eqn{Pm}) and the probability of cell proliferation (\code{Pp})
and it has no tractable likelihood function. We use the uninformative priors
\eqn{Pm ~ U(0,1)} and \eqn{Pp ~ U(0,1)}.

We have a total of 145 summary statistics, which are made up of the Hamming distances
between the binary matrices for each time point and the total number of cells at the final time.

Details about the types of cells that this model is suitable for
and other information can be found in Price et al. (2018) and An et al. (2019). Johnston et al. (2014)
use a different ABC method and different summary statistics for a similar example.
}
\section{A simulated dataset}{


An example ``observed'' dataset and the tuning parameters relevant to that example
can be obtained using \code{data(cell)}. This ``observed'' data is a simulated dataset
with \eqn{Pm = 0.35} and \eqn{Pp = 0.001}. The lattice has 27 \code{rows} and 36 \code{cols}
and there are \code{num_obs = 144} observations after time 0
(to mimic images being taken every 5 minutes for 12 hours).
The simulation is based on there initially being 110 cells in the assay.

Further information about the specific choices of tuning parameters
used in BSL and BSLasso can be found in An et al. (2019).

\itemize{
 \item \code{data}:  The \code{rows} \eqn{x} \code{cols} \eqn{x} \code{num_obs} array of the cell presences at times 1:144.
 \item \code{sim_options}: Values of \code{sim_options} relevant to this example.
 \item \code{sum_options}: Values of \code{sum_options} relevant to this example, i.e. just the value of \code{Yinit}.
 \item \code{start}: A vector of suitable initial values of the parameters for MCMC.
 \item \code{cov}: The covariance matrix of a multivariate normal random walk proposal distribution used in the MCMC, in the form of a 2 by 2 matrix
}
}

\examples{
\donttest{
require(doParallel) # You can use a different package to set up the parallel backend

# Loading the data for this example
data(cell)
model <- BSLModel(fnSim = cell_sim, fnSum = cell_sum, simArgs = cell$sim_options, 
                  sumArgs = cell$sum_options, theta0 = cell$start, fnLogPrior = cell_logPrior,
                  thetaNames = expression(P[m], P[p]))
true_cell <- c(0.35, 0.001)

# Performing BSL (reduce the number of iterations M if desired)
# Opening up the parallel pools using doParallel
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
resultCellBSL <- bsl(cell$data, n = 5000, M = 10000, model = model, covRandWalk = cell$cov,
                     parallel = TRUE, verbose = TRUE)
stopCluster(cl)
registerDoSEQ()
show(resultCellBSL)
summary(resultCellBSL)
plot(resultCellBSL, thetaTrue = true_cell, thin = 20)

# Performing uBSL (reduce the number of iterations M if desired)
# Opening up the parallel pools using doParallel
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
resultCelluBSL <- bsl(cell$data, n = 5000, M = 10000, model = model, covRandWalk = cell$cov,
                      method = 'uBSL', parallel = TRUE, verbose = TRUE)
stopCluster(cl)
registerDoSEQ()
show(resultCelluBSL)
summary(resultCelluBSL)
plot(resultCelluBSL, thetaTrue = true_cell, thin = 20)

# Performing tuning for BSLasso
ssy <- cell_sum(cell$data, cell$sum_options$Yinit)
lambda_all <- list(exp(seq(0.5,2.5,length.out=20)), exp(seq(0,2,length.out=20)),
                   exp(seq(-1,1,length.out=20)), exp(seq(-1,1,length.out=20)))
# Opening up the parallel pools using doParallel
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
set.seed(100)
sp_cell <- selectPenalty(ssy, n = c(500, 1000, 1500, 2000), lambda_all, theta = true_cell,
                         M = 100, sigma = 1.5, model = model, method = 'BSL', shrinkage = 'glasso', 
                         parallelSim = TRUE, parallelMain = FALSE)
stopCluster(cl)
registerDoSEQ()
sp_cell
plot(sp_cell)

# Performing BSLasso with a fixed penalty (reduce the number of iterations M if desired)
# Opening up the parallel pools using doParallel
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
resultCellBSLasso <- bsl(cell$data, n = 1500, M = 10000, theta0 = cell$start,
                         covRandWalk = cell$cov, fnSim = cell_sim, fnSum = cell_sum,
                         shrinkage = 'glasso', penalty = 1.3, fnPrior = cell_prior,
                         simArgs = cell$sim_options, sumArgs = cell$sum_options,
                         parallel = TRUE, parallelArgs = list(.packages = 'BSL'),
                         thetaNames = expression(P[m], P[p]), verbose = TRUE)
stopCluster(cl)
registerDoSEQ()
show(resultCellBSLasso)
summary(resultCellBSLasso)
plot(resultCellBSLasso, thetaTrue = true_cell, thin = 20)

# Performing semiBSL (reduce the number of iterations M if desired)
# Opening up the parallel pools using doParallel
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
resultCellSemiBSL <- bsl(cell$data, n = 5000, M = 10000, theta0 = cell$start,
                         covRandWalk = cell$cov, fnSim = cell_sim, fnSum = cell_sum,
                         method = 'semiBSL', fnPrior = cell_prior,
                         simArgs = cell$sim_options, sumArgs = cell$sum_options,
                         parallel = TRUE, parallelArgs = list(.packages = 'BSL'),
                         thetaNames = expression(P[m], P[p]), verbose = TRUE)
stopCluster(cl)
registerDoSEQ()
show(resultCellSemiBSL)
summary(resultCellSemiBSL)
plot(resultCellSemiBSL, thetaTrue = true_cell, thin = 20)

# Plotting the results together for comparison
# plot using the R default plot function
par(mar = c(5, 4, 1, 2), oma = c(0, 1, 2, 0))
combinePlotsBSL(list(resultCellBSL, resultCelluBSL, resultCellBSLasso, resultCellSemiBSL),
    which = 1, thetaTrue = true_cell, thin = 20, label = c('bsl', 'ubsl', 'bslasso', 'semiBSL'),
    col = 1:4, lty = 1:4, lwd = 1)
mtext('Approximate Univariate Posteriors', outer = TRUE, cex = 1.5)
}

}
\references{
An, Z., South, L. F., Nott, D. J. &  Drovandi, C. C. (2019). Accelerating Bayesian synthetic
likelihood with the graphical lasso. Journal of Computational and Graphical Statistics.
\url{https://doi.org/10.1080/10618600.2018.1537928}

Johnston, S., Simpson, M. J., McElwain, D. L. S., Binder, B. J. &
Ross, J. V. (2014). Interpreting Scratch Assays Using Pair Density
Dynamic and Approximate Bayesian Computation. Open Biology, 4, 1-11.

Price, L. F., Drovandi, C. C., Lee, A., & Nott, D. J. (2018).
Bayesian synthetic likelihood. Journal of Computational and Graphical Statistics.
\url{https://doi.org/10.1080/10618600.2017.1302882}
}
\author{
Ziwen An, Leah F. South and Christopher C. Drovandi
}
